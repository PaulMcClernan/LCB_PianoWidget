/**
Widget is a virtual mouse piano

Description:
This widget allows for creation of scalable piano controls


Name: noteOn

Type: message

Syntax: noteOn <pNoteNum>, <pNoteName>

OS: mac,ios,android,win

Platforms: desktop,mobile

Summary: Sent when a key on the piano set to it's 'on' state.

Example:
on noteOn pNoteNum,pNoteName
	put "noteOn " & pNoteNum && pNoteName
end noteOn

Parameters:

pNoteNum: The MIDI note number(s) of the note key (exp. 63), this can be an item delimited list of multiple key numbers (chords)

pNoteName: The Name of the note key (exp. D#Eb), this can be an item delimited list of multiple key numbers (chords)

Description:
Handle the <noteOn> message in the widget's object script to respond to
'note down' clicks on the piano's individual note keys.


Name: noteOff

Type: message

Syntax: noteOff <pNoteNum>, <pNoteName>

OS: mac,ios,android,win

Platforms: desktop,mobile

Summary: Sent when a key on the piano released from it's 'on' state.

Example:
on noteOff pNoteNum,pNoteName
	put "noteOff " & pNoteNum && pNoteName
end noteOff

Parameters:

pNoteNum:The MIDI note number(s) of the note key (exp. 63), this can be an item delimited list of multiple key numbers (chords)

pNoteName: The Name of the note key (exp. D#Eb), this can be an item delimited list of multiple key names (chords)

Description:
Handle the <noteOff> message in the widget's object script to respond to
'note release' messages from the piano's individual note keys.

*/

widget community.livecode.widget.piano

-- dependancy declarations
use com.livecode.canvas
use com.livecode.string
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.widgetutils

-- adding metadata to ensure the extension displays correctly in livecode
metadata title is "Piano Widget"
metadata author is "Paul McClernan, Niggemann, Bernd"
metadata version is "0.7"
metadata preferredSize is "1000,100"
metadata svgicon is "M0,0v69.6c0,1.4,1.1,2.5,2.4,2.5h9.7c0.8,0,1.5-0.4,2-1.1c0.4,0.7,1.1,1.1,2,1.1h9.8c0.8,0,1.5-0.4,1.9-1.1 c0.4,0.6,1.1,1.1,1.9,1.1h9.8c0.8,0,1.5-0.4,1.9-1.1c0.4,0.6,1.1,1.1,1.9,1.1h9.8c0.8,0,1.5-0.4,2-1.1c0.4,0.7,1.1,1.1,2,1.1h9.7 c0.8,0,1.5-0.4,1.9-1.1c0.4,0.6,1.1,1.1,1.9,1.1h9.7c0.8,0,1.5-0.4,1.9-1.1c0.4,0.6,1.1,1.1,1.9,1.1H94c1.3,0,2.4-1.1,2.4-2.5V0H0z M95.4,69.6c0,0.8-0.6,1.5-1.4,1.5h-9.8c-0.8,0-1.4-0.7-1.4-1.5V46.9h2.5c1,0,1.9-0.9,1.9-2V1h8.1L95.4,69.6z M80.4,71.1h-9.7 c-0.8,0-1.4-0.7-1.4-1.5V46.9h2.5c1,0,1.9-0.9,1.9-2V1h3.6v43.9c0,1.1,0.9,2,1.9,2h2.5v22.7C81.8,70.4,81.2,71.1,80.4,71.1z M57,71.1c-0.8,0-1.4-0.7-1.4-1.5V46.9h2.5c1,0,1.9-0.9,1.9-2V1h3.7v43.9c0,1.1,0.9,2,1.9,2h2.5v22.7c0,0.8-0.6,1.5-1.4,1.5 L57,71.1z M53.1,71.1h-9.8c-0.8,0-1.4-0.7-1.4-1.5V1H50v43.9c0,1.1,0.9,2,1.9,2h2.5v22.7C54.5,70.4,53.8,71.1,53.1,71.1z M28.3,69.6V46.9h2.5c1,0,1.9-0.9,1.9-2V1h8.1v68.6c0,0.8-0.6,1.5-1.4,1.5h-9.8C28.9,71.1,28.3,70.4,28.3,69.6z M14.7,69.6V46.9 h2.5c1,0,1.9-0.9,1.9-2V1h3.7v43.6l0,0v0.3c0,1.1,0.9,2,1.9,2h2.5v22.7c0,0.8-0.6,1.5-1.4,1.5H16C15.3,71.1,14.7,70.4,14.7,69.6z M12.1,71.1H2.4c-0.8,0-1.4-0.7-1.4-1.5V1h8.1v43.9c0,1.1,0.9,2,1.9,2h2.5v22.7C13.5,70.4,12.9,71.1,12.1,71.1z"

property hilightedNotes get getHilightedNotes set setHilightedNotes
metadata hilightedNotes.user_visible is "false"
private variable mhilightedNotes as String

private handler setHilightedNotes(pHilightNotes) returns nothing
   variable tOctave as Array
   variable tBlackKeysList as List
   variable tBlackKey as Array
   variable tWhiteKeysList as List
   variable tWhiteKey as Array

   variable tKeysList as List
   variable tKey as optional any
   variable tKeyIteration as Number

   variable tString as String
   variable tOctaveIteration as Number

   split pHilightNotes by "," into tKeysList
   -- log tKeysList

   repeat with tOctaveIteration from 1 up to 11 --- Clear All Hilights First
      put element tOctaveIteration of mOctaveList into tOctave
      put tOctave["OctaveBlackKeysList"] into tBlackKeysList
      repeat with tKeyIteration from 1 up to 5
         put element tKeyIteration of tBlackKeysList into tBlackKey
         put false into tBlackKey["KeyHighlighted"]
         put tBlackKey into element tKeyIteration of tBlackKeysList
      end repeat
      put tBlackKeysList into tOctave["OctaveBlackKeysList"]
      put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
      repeat with tKeyIteration from 1 up to 7
         put element tKeyIteration of tWhiteKeysList into tWhiteKey
         put false into tWhiteKey["KeyHighlighted"]
         put tWhiteKey into element tKeyIteration of tWhiteKeysList
      end repeat
      put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]
      put tOctave into element tOctaveIteration of mOctaveList
   end repeat

   repeat for each element tKey in tKeysList
      --log tKey
      repeat with tOctaveIteration from 1 up to 11
         put element tOctaveIteration of mOctaveList into tOctave
         put tOctave["OctaveBlackKeysList"] into tBlackKeysList
         repeat with tKeyIteration from 1 up to 5
            put element tKeyIteration of tBlackKeysList into tBlackKey
            if tBlackKey["KeyName"] is tKey then
               put true into tBlackKey["KeyHighlighted"]
               put tBlackKey into element tKeyIteration of tBlackKeysList
            else if tBlackKey["KeyName"] & tOctave["OctaveName"] is tKey then
                  put true into tBlackKey["KeyHighlighted"]
                  put tBlackKey into element tKeyIteration of tBlackKeysList
            else if tBlackKey["KeyNumber"] is tKey parsed as number then
               put true into tBlackKey["KeyHighlighted"]
               put tBlackKey into element tKeyIteration of tBlackKeysList
            end if
         end repeat
         put tBlackKeysList into tOctave["OctaveBlackKeysList"]

         put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
         repeat with tKeyIteration from 1 up to 7
            put element tKeyIteration of tWhiteKeysList into tWhiteKey
            if tWhiteKey["KeyName"] is tKey then
               put true into tWhiteKey["KeyHighlighted"]
               put tWhiteKey into element tKeyIteration of tWhiteKeysList
            else if tWhiteKey["KeyName"] & tOctave["OctaveName"] is tKey then
               put true into tWhiteKey["KeyHighlighted"]
               put tWhiteKey into element tKeyIteration of tWhiteKeysList
            else if tWhiteKey["KeyNumber"] is tKey parsed as number then
               put true into tWhiteKey["KeyHighlighted"]
               put tWhiteKey into element tKeyIteration of tWhiteKeysList
            end if
         end repeat
         put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]

         put tOctave into element tOctaveIteration of mOctaveList
      end repeat
   end repeat
   redraw all
end handler

private handler getHilightedNotes() returns String
   variable tOctave as Array
   variable tBlackKeysList as List
   variable tBlackKey as Array
   variable tWhiteKeysList as List
   variable tWhiteKey as Array
   variable tPath as Path
   variable tNamesString as String
   variable tNoteNumsString as String
   variable tOctaveIteration as Number
   put "" into tNamesString
   put "" into tNoteNumsString
   repeat with tOctaveIteration from 1 up to 11
      put element (tOctaveIteration) of mOctaveList into tOctave
      --log tOctave["OctaveName"]
      put tOctave["OctaveBlackKeysList"] into tBlackKeysList
      repeat for each element tBlackKey in tBlackKeysList
         --log tBlackKey["KeyName"]
         --log tBlackKey["KeyHighlighted"]
         if tBlackKey["KeyHighlighted"] is true then
            put tBlackKey["KeyNumber"] formatted as string & "," after tNoteNumsString
            put tBlackKey["KeyName"] & tOctave["OctaveName"] & "," after tNamesString
         end if
      end repeat
      put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
      repeat for each element tWhiteKey in tWhiteKeysList
         --log tBlackKey["KeyName"]
         --log tBlackKey["KeyHighlighted"]
         if tWhiteKey["KeyHighlighted"] is true then
            put tWhiteKey["KeyNumber"] formatted as string & "," after tNoteNumsString
            put tWhiteKey["KeyName"] & tOctave["OctaveName"] & "," after tNamesString
         end if
      end repeat
   end repeat
   if tNamesString is not the empty string then
      if the last char of tNamesString is "," then
         delete the last char of tNamesString
      end if
   end if
   if tNoteNumsString is not the empty string then
      if the last char of tNoteNumsString is "," then
         delete the last char of tNoteNumsString
      end if
   end if
   return tNoteNumsString &"\n"& tNamesString
end handler

property octaves  get getOctaveAmount  set setOctaveAmount
metadata octaves.editor is "com.livecode.pi.enum"
metadata octaves.options is "1,2,3,4,5,6,7,8,9,10,11"
metadata octaves.default is "11"
metadata octaves.label is "Octaves Amount"
private variable mOctavesStr as String
private variable mOctaves as Integer

property chordFormula get getChordFormula  set setChordFormula
metadata chordFormula.editor is "com.livecode.pi.string"
metadata chordFormula.default is ""
metadata chordFormula.label is "Chord Formula"
public variable mChordFormula as String

property chordPreset get getChordPreset set setChordPreset
metadata chordPreset.editor is "com.livecode.pi.enum"
metadata chordPreset.options is "...,+Octave,-Octave,-Octave+Octave,PowerChord,Major Triad,Minor Triad,Minor 7th,Major 7th"
metadata chordPreset.default is "None"
metadata chordPreset.label is "Chord Presets"
public variable mChordPreset as String

property iconHiliteColor   get getHiliteColor   set setHiliteColor
metadata iconHiliteColor.editor is "com.livecode.pi.color"
private variable mHiliteColor as Color

public variable mPianoMouseButtonDown as Boolean

private variable mBlackKeysList as List
private variable mWhiteKeysList as List
private variable mSelectedKeyList as optional List
private variable mSelectedKey as optional Array
private variable mOctaveList as List

-- added private variables
private variable mWhiteBottomDistance as Number -- distance of white keys from bottom, can be negative
private variable mStrokeWidth  as Number -- stroke width
private variable mXRounded as Number -- the X amount of rounded rectangle
private variable mYRounded as Number -- the Y amount of rounded rectangle
private variable mTopCoverHeight as Number -- optional cover over rounded top of keys
private variable mYTranslate as Number  -- Y offset to hide rounded corners at top
private variable mNeedsScaling as Boolean -- set to true when geometry changes and rebuilds list in OnPaint
--  end added  private variables

private handler setChordFormula(in pChordFormula as String) returns nothing
   put pChordFormula into mChordFormula
   if mChordPreset is not "..." then
      put "..." into mChordPreset
   end if
   OnGeometryChanged()
   redraw all
end handler

private handler setChordPreset(in pChordPreset as String) returns nothing
   if pChordPreset is "..." then
      put pChordPreset into mChordPreset
      setChordFormula("")
   end if
   if pChordPreset is "+Octave" then
      put pChordPreset into mChordPreset
      setChordFormula("12")
   end if
   if pChordPreset is "-Octave" then
      put pChordPreset into mChordPreset
      setChordFormula("-12")
   end if
   if pChordPreset is "-Octave+Octave" then
      put pChordPreset into mChordPreset
      setChordFormula("-12,12")
   end if
   if pChordPreset is "PowerChord" then
      put pChordPreset into mChordPreset
      setChordFormula("7,12")
   end if
   if pChordPreset is "Major Triad" then
      put pChordPreset into mChordPreset
      setChordFormula("4,7")
   end if
   if pChordPreset is "Minor Triad" then
      put pChordPreset into mChordPreset
      setChordFormula("3,7")
   end if
   if pChordPreset is "Major 7th" then
      put pChordPreset into mChordPreset
      setChordFormula("4,7,11")
   end if
   if pChordPreset is "Minor 7th" then
      put pChordPreset into mChordPreset
      setChordFormula("3,7,11")
   end if
   OnGeometryChanged()
   redraw all
end handler

public handler setOctaveAmount(in pOctavesStr as String) returns nothing
   put pOctavesStr into mOctavesStr
	put (pOctavesStr parsed as number) into mOctaves
   OnGeometryChanged()
   redraw all
end handler

public handler setHiliteColor(in pColor as String) returns nothing
   put stringToColor(pColor) into mHiliteColor
   OnGeometryChanged()
   redraw all
end handler

public handler getChordPreset() returns String
   return mChordPreset
end handler

public handler getChordFormula() returns String
   return mChordFormula
end handler

public handler getOctaveAmount() returns String
   return mOctavesStr
end handler

public handler getHiliteColor() returns String
   return colorToString(mHiliteColor, false)
end handler

public handler OnStopEditing()
   trigger all
   OnGeometryChanged()
end handler
--------------------------------------------------------------------------------------------------------------
-- called whenever LiveCode needs to redraw the widget
public handler OnPaint()

   if mNeedsScaling then -- when geometry changed build new
      put the empty list into mOctaveList
      createDataRoundedRect()
      put false into mNeedsScaling
   end if
   
   variable tOctave as Array
   variable tBlackKeysList as List
   variable tBlackKey as Array
   variable tWhiteKeysList as List
	variable tWhiteKey as Array
	variable tPath as Path
   variable tString as String
   variable tOctaveIteration as Number

   set the antialias of this canvas to true
   set the stroke width of this canvas to 1.5
   repeat with tOctaveIteration from 1 up to mOctaves
      put element (tOctaveIteration) of mOctaveList into tOctave
   	------------------------------------------------------------------------------------------ WhiteKeys ------------------------------------------------------------------------------------------
      put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
      ------------------------------------------------------------------------------------------------------------------ C
   	put element 1 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ D
   	put element 2 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ E
   	put element 3 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ F
   	put element 4 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
      fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ G
   	put element 5 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ A
   	put element 6 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ B
   	put element 7 of tWhiteKeysList into tWhiteKey
   	if tWhiteKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [1,1,1,1]
   	end if
   	put tWhiteKey["KeyPath"] into tPath
   	fill tPath on this canvas
      set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------ Black Keys ------------------------------------------------------------------------------------------
      put tOctave["OctaveBlackKeysList"] into tBlackKeysList
      ------------------------------------------------------------------------------------------------------------------ C#Db
   	put element 1 of tBlackKeysList into tBlackKey
   	if tBlackKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [0,0,0,1]
   	end if
   	put tBlackKey["KeyPath"] into tPath
   	fill tPath on this canvas
      --set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
      ------------------------------------------------------------------------------------------------------------------ D#Eb
   	put element 2 of tBlackKeysList into tBlackKey
   	if tBlackKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [0,0,0,1]
   	end if
   	put tBlackKey["KeyPath"] into tPath
   	fill tPath on this canvas
      --set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ F#Gb
   	put element 3 of tBlackKeysList into tBlackKey
   	if tBlackKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [0,0,0,1]
   	end if
   	put tBlackKey["KeyPath"] into tPath
      fill tPath on this canvas
      --set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ G#Ab
   	put element 4 of tBlackKeysList into tBlackKey
   	if tBlackKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [0,0,0,1]
   	end if
   	put tBlackKey["KeyPath"] into tPath
   	fill tPath on this canvas
      --set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas
   	------------------------------------------------------------------------------------------------------------------ A#Bb
   	put element 5 of tBlackKeysList into tBlackKey
   	if tBlackKey["KeyHighlighted"] then
   		set the paint of this canvas to solid paint with mHiliteColor
   	else
   		set the paint of this canvas to solid paint with color [0,0,0,1]
   	end if
   	put tBlackKey["KeyPath"] into tPath
   	fill tPath on this canvas
      --set the paint of this canvas to solid paint with color [0,0,0,1]
      stroke tPath on this canvas

   end repeat
   
   -- draw a black line at the top to hide rounded corners
   set the paint of this canvas to solid paint with color [0,0,0,1]
   variable tTopLine as Rectangle
   put my bounds into tTopLine
   put mTopCoverHeight into the bottom of tTopLine
   put rectangle path of tTopLine into tPath
   fill tPath on this canvas
   
end handler

public handler OnOpen()
   OnGeometryChanged()
end handler

public handler OnGeometryChanged()
   put true into mNeedsScaling
   redraw all
end handler

-- this handler is called when the widget is saved
public handler OnSave(out rProperties as Array)
	-- put colorToString(mColor, true) into rProperties["color"]
end handler
-- this handler is called when the widget is loaded
public handler OnLoad(in pProperties as Array)
	-- put stringToColor(pProperties["color"]) into mColor
   -- put stringToColor(pProperties["hilite color"]) into mHiliteColor
end handler

----------------------------------------------------------------------------------------------------
public handler OnMouseUp()
   variable tOctave as Array
   variable tBlackKeysList as List
   variable tBlackKey as Array
   variable tWhiteKeysList as List
   variable tWhiteKey as Array
   variable tPath as Path
   variable tIndex as Number
   variable tNotesNumsOff as List
   put false into  mPianoMouseButtonDown
   --- execute script "global gPianoMouseButtonDown ; put false into gPianoMouseButtonDown"
   if mSelectedKey is not nothing then
      if mSelectedKey["keycolor"] is "black" then
         put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tNotesNumsOff
         put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
         post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tNotesNumsOff, mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tNotesNumsOff ]
         put tOctave["OctaveBlackKeysList"] into tBlackKeysList
         put element (mSelectedKey["index"]) of tBlackKeysList into tBlackKey
         put false into tBlackKey["KeyHighlighted"]
         put tBlackKey into element mSelectedKey["index"] of tBlackKeysList
         put tBlackKeysList into tOctave["OctaveBlackKeysList"]
         put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
      else
         put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tNotesNumsOff
         put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
         post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tNotesNumsOff, mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tNotesNumsOff ]
         put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
         put element mSelectedKey["index"] of tWhiteKeysList into tWhiteKey
         put false into tWhiteKey["KeyHighlighted"]
         put tWhiteKey into element mSelectedKey["index"] of tWhiteKeysList
         put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]
         put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
      end if
      put nothing into mSelectedKey
      redraw all
   end if
   -- redraw all
  post "mouseUp" with [the click button]
 -- post "mouseUp" to my script object with [the click button]
end handler

----------------------------------------------------------------------------------------------------


public handler OnMouseCancel()
      -- put false into gPianoMouseButtonDown
      --- execute script "global gPianoMouseButtonDown ; put false into gPianoMouseButtonDown"
	--redraw all
end handler

public handler OnMouseEnter()
   --put false into gPianoMouseButtonDown
   --execute script "global gPianoMouseButtonDown ; return gPianoMouseButtonDown"
   --put the result into gPianoMouseButtonDown
   -- log gPianoMouseButtonDown
end handler

-- OctaveList
--    OctaveName
--    OctaveNumber
--    OctaveBackgroundPath
--    BlackKeysList
--       KeyName
--       KeyNumber
--       KeyPath
--       KeyHighlighted
--    WhiteKeysList
--       KeyName
--       KeyNumber
--       KeyPath
--       KeyHighlighted

public handler OnMouseDown()
   variable tOctaveCounter as Number
   variable tOctave as Array
   variable tBlackKeysList as List
   variable tBlackKey as Array
   variable tWhiteKeysList as List
   variable tWhiteKey as Array
   variable tPath as Path
   variable tIndex as Number
   variable tChordNotes as List
   
   variable tMouseLoc as Point
   variable tBlackWasFound as Boolean
   
   put the mouse position into tMouseLoc
   
   put true into mPianoMouseButtonDown
   if mSelectedKey is not nothing then
      put mSelectedKey["KeyPath"] into tPath
      if not (tMouseLoc is within the bounding box of tPath) then
         if mSelectedKey["keycolor"] is "black" then
            put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tChordNotes
            put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
            post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tChordNotes, mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes ]
            put tOctave["OctaveBlackKeysList"] into tBlackKeysList
            put element mSelectedKey["index"] of tBlackKeysList into tBlackKey
            put false into tBlackKey["KeyHighlighted"]
            put tBlackKey into element mSelectedKey["index"] of tBlackKeysList
            put tBlackKeysList into tOctave["OctaveBlackKeysList"]
            put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
         else
            put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tChordNotes
            put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
            post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tChordNotes, mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes ]
            put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
            put element mSelectedKey["index"] of tWhiteKeysList into tWhiteKey
            put false into tWhiteKey["KeyHighlighted"]
            put tWhiteKey into element mSelectedKey["index"] of tWhiteKeysList
            put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]
            put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
         end if
         put nothing into mSelectedKey
      end if
   end if
   repeat with tOctaveCounter from 1 up to mOctaves
      put element tOctaveCounter of mOctaveList into tOctave

      put tOctave["OctaveBlackKeysList"] into tBlackKeysList
      repeat with tIndex from 1 up to 5
         put element tIndex of tBlackKeysList into tBlackKey
         put tBlackKey["KeyPath"] into tPath
         if (tMouseLoc is within the bounding box of tPath) then
            put highlightChordFormula(tBlackKey["KeyNumber"]) into tChordNotes
            post "noteOn" with [ tBlackKey["KeyNumber"] formatted as string & element 1 of tChordNotes,tBlackKey["KeyName"]&tOctave["OctaveName"]& element 2 of tChordNotes]
            put true into tBlackKey["KeyHighlighted"]
            put tBlackKey into element tIndex of tBlackKeysList
            put tBlackKey into mSelectedKey
            put tIndex into mSelectedKey["index"]
            put "black" into mSelectedKey["keycolor"]
            put tOctaveCounter into mSelectedKey["OctaveNumber"]
	    put true into tBlackWasFound
         else
           put false into tBlackKey["KeyHighlighted"]
           put tBlackKey into element tIndex of tBlackKeysList
         end if
      end repeat
      put tBlackKeysList into tOctave["OctaveBlackKeysList"]

      put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
      if not tBlackWasFound then
         repeat with tIndex from 1 up to 7
	    put element tIndex of tWhiteKeysList into tWhiteKey
	    put tWhiteKey["KeyPath"] into tPath
	    if (tMouseLoc is within the bounding box of tPath) then
	       put highlightChordFormula(tWhiteKey["KeyNumber"]) into tChordNotes
	       post "noteOn" with [ tWhiteKey["KeyNumber"] formatted as string & element 1 of tChordNotes,tWhiteKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes]
	       put true into tWhiteKey["KeyHighlighted"]
	       put tWhiteKey into element tIndex of tWhiteKeysList
	       put tWhiteKey into mSelectedKey
	       put tIndex into mSelectedKey["index"]
	       put "white" into mSelectedKey["keycolor"]
	       put tOctaveCounter into mSelectedKey["OctaveNumber"]
	    else
	       put false into tWhiteKey["KeyHighlighted"]
	       put tWhiteKey into element tIndex of tWhiteKeysList
	    end if
         end repeat
      end if
      put false into tBlackWasFound
      put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]

      put tOctave into element tOctaveCounter of mOctaveList
   end repeat
   if mSelectedKey is not nothing then
      highlightChordFormula(mSelectedKey["KeyNumber"])
   end if
   redraw all
   post "mouseDown" with [the click button]
   -- post "mouseDown" to my script object with [the click button]
end handler

public handler OnMouseMove()
   if mPianoMouseButtonDown then
      variable tOctaveCounter as Number
      variable tOctave as Array
      variable tBlackKeysList as List
      variable tBlackKey as Array
      variable tWhiteKeysList as List
      variable tWhiteKey as Array
      variable tPath as Path
      variable tIndex as Number
      variable tNum as Number
      variable tChordNotes as List
	
      variable tMouseLoc as Point
      variable tBlackWasFound as Boolean

      put the mouse position into tMouseLoc
      
      if mSelectedKey is not nothing then
         put mSelectedKey["KeyPath"] into tPath
         if not (tMouseLoc is within the bounding box of tPath) then
            if mSelectedKey["keycolor"] is "black" then
               put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
               put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tChordNotes
               post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tChordNotes,mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes]
               --post "noteOff" with [ mSelectedKey["KeyNumber"], mSelectedKey["KeyName"]&tOctave["OctaveName"]]
               put tOctave["OctaveBlackKeysList"] into tBlackKeysList
               put element mSelectedKey["index"] of tBlackKeysList into tBlackKey
               put false into tBlackKey["KeyHighlighted"]
               put tBlackKey into element mSelectedKey["index"] of tBlackKeysList
               put tBlackKeysList into tOctave["OctaveBlackKeysList"]
               put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
            else
               put element mSelectedKey["OctaveNumber"] of mOctaveList into tOctave
               put unhighlightChordFormula(mSelectedKey["KeyNumber"]) into tChordNotes
               post "noteOff" with [ mSelectedKey["KeyNumber"] formatted as string & element 1 of tChordNotes,mSelectedKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes]
               --post "noteOff" with [ mSelectedKey["KeyNumber"], mSelectedKey["KeyName"]&tOctave["OctaveName"]]
               put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
               put element mSelectedKey["index"] of tWhiteKeysList into tWhiteKey
               put false into tWhiteKey["KeyHighlighted"]
               put tWhiteKey into element mSelectedKey["index"] of tWhiteKeysList
               put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]
               put tOctave into element mSelectedKey["OctaveNumber"] of mOctaveList
            end if
         end if
      end if
      
         repeat with tOctaveCounter from 1 up to mOctaves
            put element tOctaveCounter of mOctaveList into tOctave
            put tOctave["OctaveBlackKeysList"] into tBlackKeysList
            repeat with tIndex from 1 up to 5
               put element tIndex of tBlackKeysList into tBlackKey
               put tBlackKey["KeyPath"] into tPath
               if (tMouseLoc is within the bounding box of tPath) then
	          put true into tBlackWasFound
                  put highlightChordFormula(tBlackKey["KeyNumber"]) into tChordNotes
                  post "noteOn" with [ tBlackKey["KeyNumber"] formatted as string & element 1 of tChordNotes,tBlackKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes]
                  -- post "noteOn" with [ tBlackKey["KeyNumber"],tBlackKey["KeyName"]&tOctave["OctaveName"]]
                   put true into tBlackKey["KeyHighlighted"]
                   put tBlackKey into element tIndex of tBlackKeysList
                   put tBlackKey into mSelectedKey
                   put tIndex into mSelectedKey["index"]
                   put "black" into mSelectedKey["keycolor"]
                   put tOctaveCounter into mSelectedKey["OctaveNumber"]
               else
                 put false into tBlackKey["KeyHighlighted"]
                 put tBlackKey into element tIndex of tBlackKeysList
               end if
            end repeat
            put tBlackKeysList into tOctave["OctaveBlackKeysList"]

            put tOctave["OctaveWhiteKeysList"] into tWhiteKeysList
            repeat with tIndex from 1 up to 7
               put element tIndex of tWhiteKeysList into tWhiteKey
               put tWhiteKey["KeyPath"] into tPath
               if (tMouseLoc is within the bounding box of tPath) and (not tBlackWasFound) then
                  put highlightChordFormula(tWhiteKey["KeyNumber"]) into tChordNotes
                  post "noteOn" with [ tWhiteKey["KeyNumber"] formatted as string & element 1 of tChordNotes,tWhiteKey["KeyName"]&tOctave["OctaveName"] & element 2 of tChordNotes]
                  -- post "noteOn" with [ tWhiteKey["KeyNumber"],tWhiteKey["KeyName"]&tOctave["OctaveName"]]
                  put true into tWhiteKey["KeyHighlighted"]
                  put tWhiteKey into element tIndex of tWhiteKeysList
                  put tWhiteKey into mSelectedKey
                  put tIndex into mSelectedKey["index"]
                  put "white" into mSelectedKey["keycolor"]
                  put tOctaveCounter into mSelectedKey["OctaveNumber"]
               else
                  put false into tWhiteKey["KeyHighlighted"]
                  put tWhiteKey into element tIndex of tWhiteKeysList
               end if
            end repeat
            put false into tBlackWasFound
            put tWhiteKeysList into tOctave["OctaveWhiteKeysList"]
            put tOctave into element tOctaveCounter of mOctaveList
         end repeat
         if mSelectedKey is not nothing then
           highlightChordFormula(mSelectedKey["KeyNumber"])
         end if
      redraw all
   end if
end handler

public handler unhighlightChordFormula(in pKeyNum as Integer) returns optional any
   variable tListOfString as List
   variable tListOfNum as List
   variable tChordNoteNums as List
   variable tKeysList as List
   variable tKey as Array
   variable tNum as Number
   variable tOctNum as Number
   variable tOctave as Array
   variable tCounter as Number
   variable tNoteNumsOff as String
   variable tNoteNamesOff as String
   variable tNotesOff as List
   split mChordFormula by "," into tListOfString
   put tListOfString parsed as list of number into tListOfNum
   repeat for each element tNum in tListOfNum
      if pKeyNum + tNum < 128 and pKeyNum + tNum > -1 then
         push pKeyNum + tNum onto tChordNoteNums
      end if
   end repeat
   repeat for each element tNum in tChordNoteNums
      put getOctaveFromNoteNumber(tNum) into tOctNum
      put element tOctNum of mOctaveList into tOctave
      if tNum is in tOctave["OctaveBlackKeysIndex"] then
         put tOctave["OctaveBlackKeysList"] into tKeysList
         repeat with tCounter from 1 up to 5
            put element tCounter of tKeysList into tKey
            if tKey["KeyNumber"] is tNum then
               put "," &  tKey["KeyName"] & tOctave["OctaveName"] after tNoteNamesOff
               put "," & tKey["KeyNumber"] formatted as string after tNoteNumsOff
               put false into tKey["KeyHighlighted"]
               put tKey into element tCounter of tKeysList
            end if
         end repeat
         put tKeysList into tOctave["OctaveBlackKeysList"]
         put tOctave into element tOctNum of mOctaveList
         redraw all
      else
         if tNum is in tOctave["OctaveWhiteKeysIndex"] then
            put tOctave["OctaveWhiteKeysList"] into tKeysList
            repeat with tCounter from 1 up to 7
               put tKeysList[tCounter] into tKey
               if tKey["KeyNumber"] is tNum then
                  put "," &  tKey["KeyName"] & tOctave["OctaveName"] after tNoteNamesOff
                  put "," & tKey["KeyNumber"] formatted as string after tNoteNumsOff
                  put false into tKey["KeyHighlighted"]
                  put tKey into tKeysList[tCounter]
               end if
            end repeat
            put tKeysList into tOctave["OctaveWhiteKeysList"]
            put tOctave into element tOctNum of mOctaveList
         end if
      end if
   end repeat
   push tNoteNumsOff onto tNotesOff
   push tNoteNamesOff onto tNotesOff
   return tNotesOff
end handler

public handler highlightChordFormula(in pKeyNum as Integer) returns optional any
   variable tListOfString as List
   variable tListOfNum as List
   variable tChordNoteNums as List
   variable tKeysList as List
   variable tKey as Array
   variable tNum as Number
   variable tOctNum as Number
   variable tOctave as Array
   variable tCounter as Number
   variable tNoteNumsOn as String
   variable tNoteNamesOn as String
   variable tNotesOn as List
   split mChordFormula by "," into tListOfString
   put tListOfString parsed as list of number into tListOfNum
   repeat for each element tNum in tListOfNum
      if pKeyNum + tNum < 128 and pKeyNum + tNum > -1 then
         push pKeyNum + tNum onto tChordNoteNums
      end if
   end repeat
   repeat for each element tNum in tChordNoteNums
      put getOctaveFromNoteNumber(tNum) into tOctNum
      put element tOctNum of mOctaveList into tOctave
      if tNum is in tOctave["OctaveBlackKeysIndex"] then
         put tOctave["OctaveBlackKeysList"] into tKeysList
         repeat with tCounter from 1 up to 5
            put element tCounter of tKeysList into tKey
            if tKey["KeyNumber"] is tNum then
               put "," &  tKey["KeyName"] & tOctave["OctaveName"] after tNoteNamesOn
               put "," & tKey["KeyNumber"] formatted as string after tNoteNumsOn
               put true into tKey["KeyHighlighted"]
               put tKey into element tCounter of tKeysList
            end if
         end repeat
         put tKeysList into tOctave["OctaveBlackKeysList"]
         put tOctave into element tOctNum of mOctaveList
      else
         if tNum is in tOctave["OctaveWhiteKeysIndex"] then
            put tOctave["OctaveWhiteKeysList"] into tKeysList
            repeat with tCounter from 1 up to 7
               put tKeysList[tCounter] into tKey
               if tKey["KeyNumber"] is tNum then
                  put "," & tKey["KeyName"] & tOctave["OctaveName"] after tNoteNamesOn
                  put "," & tKey["KeyNumber"] formatted as string after tNoteNumsOn
                  put true into tKey["KeyHighlighted"]
                  put tKey into tKeysList[tCounter]
               end if
            end repeat
            put tKeysList into tOctave["OctaveWhiteKeysList"]
            put tOctave into element tOctNum of mOctaveList
         end if
      end if
   end repeat
   -- delete the last char of tNoteNumsOn
   -- delete the last char of tNoteNamesOn
   -- log tNoteNumsOn
   -- log tNoteNamesOn
   push tNoteNumsOn onto tNotesOn
   push tNoteNamesOn onto tNotesOn
   return tNotesOn
end handler

public handler getOctaveFromNoteNumber(in pNoteNum as Integer) returns optional any
   if pNoteNum < 12 then
      return 1
   end if
   if pNoteNum>11 and pNoteNum<24 then
      return 2
   end if
   if pNoteNum>23 and pNoteNum<36 then
      return 3
   end if
   if pNoteNum>35 and pNoteNum<48 then
      return 4
   end if
   if pNoteNum>47 and pNoteNum<60 then
      return 5
   end if
   if pNoteNum>59 and pNoteNum<72 then
      return 6
   end if
   if pNoteNum>71 and pNoteNum<84 then
      return 7
   end if
   if pNoteNum>83 and pNoteNum<96 then
      return 8
   end if
   if pNoteNum>95 and pNoteNum<108 then
      return 9
   end if
   if pNoteNum>107 and pNoteNum<120 then
      return 10
   end if
   if pNoteNum>119 and pNoteNum<128 then
      return 11
   end if
end handler

--- called when widget is created
public handler OnCreate()
   put stringToColor("0,255,0") into mHiliteColor

   put nothing into mSelectedKey
   put false into mPianoMouseButtonDown
   put 15 into mXRounded -- X amount of rounding rectangle
   put 5 into mYRounded -- Y amount of rounding rectangle
   put 1 into mTopCoverHeight -- a line at the top of widget
   put -4 into mWhiteBottomDistance -- compensate for shift upwards to hide top
   put -5 into mYTranslate -- to cut off the top of rounded rects

   createDataRoundedRect()

end handler

private handler createDataRoundedRect() returns nothing
   -- OctaveList
   --    OctaveName
   --    OctaveNumber
   --    OctaveBackgroundPath
   --    BlackKeysList
   --       KeyName
   --       KeyNumber
   --       KeyPath
   --       KeyHighlighted
   --    WhiteKeysList
   --       KeyName
   --       KeyNumber
   --       KeyPath
   --       KeyHighlighted


   variable tBlackKeysList as List
   variable tWhiteKeysList as List

   variable tPath as Path
   variable tArray as Array

   put the empty array into tArray
   put the empty list into tBlackKeysList
   put the empty list into tWhiteKeysList


   variable tMyBounds as Rectangle
   variable tHeight as Number
   variable tWidth as Number
   variable tLeft as Number
   variable tBottom as Number
   variable tWhiteWidth as Number
   variable tWhiteRect as Rectangle
   variable tWhitePath as Path
   variable tBlackHeight as Number
   variable tBlackWidth as Number
   variable tBlackKeyWidth as Number
   variable tBlackKeyRect as Rectangle
   variable tBlackPath as Path

   put my bounds into tMyBounds
   put the width of tMyBounds into tWidth
   put the height of tMyBounds into tHeight
   put the left of tMyBounds into tLeft
   put the bottom of tMyBounds into tBottom

   put ((tWidth) / (7 * mOctaves)) into tWhiteWidth
   put rectangle [0,0,tWhiteWidth, tHeight - mWhiteBottomDistance] into tWhiteRect
   put rounded rectangle path of tWhiteRect with radii [mXRounded, mYRounded] into tWhitePath

   put (tHeight * .65) into tBlackHeight
   put (tWhiteWidth * .6) into tBlackwidth
   put rectangle [0, 0, tBlackWidth, tBlackHeight] into tBlackKeyRect
   put rounded rectangle path of tBlackKeyRect with radii [mXRounded, mYRounded] into tBlackPath
   -- translate tBlackPath by [(tWhiteWidth) - (tBlackWidth / 2), mYTranslate]
   --translate tBlackPath by the width of tBlackKeyRect/2,

   variable tWhiteKeySequence as List
   variable tBlackKeySequence as List

   put ["C","D","E","F","G","A","B"] into tWhiteKeySequence
   put ["C#Db","D#Eb","","F#Gb","G#Ab","A#Bb",""] into tBlackKeySequence

   variable incOctaves as Number -- counter of octaves
   variable incOneOctave as Number -- counter from 1 to 7
   variable tOctaves as Number
   put mOctaves into tOctaves

   variable tSequentialNumber as Number
   put -1 into tSequentialNumber

   variable tSumWidths as Number
   put 0 into tSumWidths

   variable tWhiteKeyRightRef as Number
   variable tTranslateX as Number

   variable tOctaveBlackKeysIndex as List
   variable tOctaveWhiteKeysIndex as List
   variable tWhitePathTemp as Path
   variable tBlackPathTemp as Path

   repeat with incOctaves from -1 up to 11 -2
      repeat with incOneOctave from 1 up to 7

         -- white keys
         add 1 to tSequentialNumber
         push tSequentialNumber onto tOctaveWhiteKeysIndex
         put element incOneOctave of tWhiteKeySequence into tArray["KeyName"]
         put tWhitePath into tWhitePathTemp
			translate tWhitePathTemp by [tSumWidths, mYTranslate]
         add tWhiteWidth to tSumWidths
         put tWhitePathTemp into tArray["KeyPath"]
         put the bounding box of tWhitePathTemp into tArray["boundingBox"]
         put the right of the bounding box of tWhitePathTemp into tWhiteKeyRightRef
         -- log the top of the bounding box of tWhitePathTemp
         put false into tArray["KeyHighlighted"]
         put tSequentialNumber into tArray["KeyNumber"]
         push tArray onto tWhiteKeysList

         -- black keys

         -- 3 and 7 are "missing" black keys
         if incOneOctave = 3 or incOneOctave = 7  then
            next repeat
         end if

         put the empty array into tArray
         add 1 to tSequentialNumber
         push tSequentialNumber onto tOctaveBlackKeysIndex
         put element incOneOctave of tBlackKeySequence into tArray["KeyName"]
         put tWhiteKeyRightRef - (tBlackWidth/2 )  into tTranslateX
         put tBlackPath into tBlackPathTemp
			translate tBlackPathTemp by [tTranslateX, mYTranslate]
         put tBlackPathTemp into tArray["KeyPath"]
         put the bounding box of tBlackPathTemp into tArray["boundingBox"]
         put false into tArray["KeyHighlighted"]
         put tSequentialNumber into tArray["KeyNumber"]
         push tArray onto tBlackKeysList
      end  repeat

      put the empty array into tArray
      put incOctaves formatted as string  into tArray["OctaveName"]
      put incOctaves + 2 into tArray["OctaveNumber"]
      put path "" into tArray["OctaveBackgroundPath"]
      put tBlackKeysList into tArray["OctaveBlackKeysList"]
      log [tArray["OctaveBlackKeysList"]]
      put tWhiteKeysList into tArray["OctaveWhiteKeysList"]
      put tOctaveBlackKeysIndex into tArray["OctaveBlackKeysIndex"]
      put tOctaveWhiteKeysIndex into tArray["OctaveWhiteKeysIndex"]
      push tArray onto mOctaveList

      put the empty array into tArray
      put the empty list into tBlackKeysList
      put the empty list into tWhiteKeysList
   end repeat
end handler

end widget
